<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/index.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/jrop/pratt" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/index.js~Parser.html">Parser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/index.js~ParserBuilder.html">ParserBuilder</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const createStop = () =&gt; {
    let stopCalled = false;
    return Object.assign((x) =&gt; {
        stopCalled = true;
        return x;
    }, {
        isStopped() {
            return stopCalled;
        },
    });
};
/**
 * A Pratt parser.
 * @example
 * const lex = new perplex.Lexer(&apos;1 + -2 * 3^4&apos;)
 *   .token(&apos;NUM&apos;, /\d+/)
 *   .token(&apos;+&apos;, /\+/)
 *   .token(&apos;-&apos;, /-/)
 *   .token(&apos;*&apos;, new RegExp(&apos;*&apos;))
 *   .token(&apos;/&apos;, /\//)
 *   .token(&apos;^&apos;, /\^/)
 *   .token(&apos;(&apos;, /\(/)
 *   .token(&apos;)&apos;, /\)/)
 *   .token(&apos;$SKIP_WS&apos;, /\s+/)
 *
 * const parser = new Parser(lex)
 *   .builder()
 *   .nud(&apos;NUM&apos;, 100, t =&gt; parseInt(t.match))
 *   .nud(&apos;-&apos;, 10, (t, bp) =&gt; -parser.parse(bp))
 *   .nud(&apos;(&apos;, 10, (t, bp) =&gt; {
 *     const expr = parser.parse(bp)
 *     lex.expect(&apos;)&apos;)
 *     return expr
 *   })
 *   .bp(&apos;)&apos;, 0)
 *
 *   .led(&apos;^&apos;, 20, (left, t, bp) =&gt; Math.pow(left, parser.parse(20 - 1)))
 *   .led(&apos;+&apos;, 30, (left, t, bp) =&gt; left + parser.parse(bp))
 *   .led(&apos;-&apos;, 30, (left, t, bp) =&gt; left - parser.parse(bp))
 *   .led(&apos;*&apos;, 40, (left, t, bp) =&gt; left * parser.parse(bp))
 *   .led(&apos;/&apos;, 40, (left, t, bp) =&gt; left / parser.parse(bp))
 *   .build()
 * parser.parse()
 * // =&gt; 161
 */
export class Parser {
    /**
     * Constructs a Parser instance
     * @param {ILexer&lt;T&gt;} lexer The lexer to obtain tokens from
     */
    constructor(lexer) {
        /**
         * The lexer that this parser is operating on.
         * @type {ILexer&lt;T&gt;}
         */
        this.lexer = lexer;
        this._nuds = new Map();
        this._leds = new Map();
        this._bps = new Map();
    }
    _type(tokenOrType) {
        return tokenOrType &amp;&amp; typeof tokenOrType.isEof == &apos;function&apos;
            ? tokenOrType.type
            : tokenOrType;
    }
    /**
     * Create a {@link ParserBuilder}
     * @return {ParserBuilder&lt;T&gt;} Returns the ParserBuilder
     */
    builder() {
        return new ParserBuilder(this);
    }
    /**
     * Define binding power for a token-type
     * @param {IToken&lt;T&gt;|T} tokenOrType The token type to define the binding power for
     * @returns {number} The binding power of the specified token type
     */
    bp(tokenOrType) {
        if (tokenOrType == null)
            return Number.NEGATIVE_INFINITY;
        if (tokenOrType &amp;&amp;
            typeof tokenOrType.isEof == &apos;function&apos; &amp;&amp;
            tokenOrType.isEof())
            return Number.NEGATIVE_INFINITY;
        const type = this._type(tokenOrType);
        return this._bps.has(type) ? this._bps.get(type) : Number.POSITIVE_INFINITY;
    }
    /**
     * Computes the token&apos;s `nud` value and returns it
     * @param {NudInfo&lt;T&gt;} info The info to compute the `nud` from
     * @returns {any} The result of invoking the pertinent `nud` operator
     */
    nud(info) {
        const bp = this.bp(info.token);
        let fn = this._nuds.get(info.token.type);
        if (!fn) {
            const { start } = info.token.strpos();
            throw new Error(`Unexpected token: ${info.token.match} (at ${start.line}:${start.column})`);
        }
        return fn(info);
    }
    /**
     * Computes a token&apos;s `led` value and returns it
     * @param {LedInfo&lt;T&gt;} info The info to compute the `led` value for
     * @returns {any} The result of invoking the pertinent `led` operator
     */
    led(info) {
        const bp = this.bp(info.token);
        let fn = this._leds.get(info.token.type);
        if (!fn) {
            const { start } = info.token.strpos();
            throw new Error(`Unexpected token: ${info.token.match} (at ${start.line}:${start.column})`);
        }
        return fn(info);
    }
    /**
     * Kicks off the Pratt parser, and returns the result
     * @param {ParseOpts&lt;T&gt;} opts The parse options
     * @returns {any}
     */
    parse(opts = { terminals: [0] }) {
        const stop = createStop();
        const check = () =&gt; {
            if (stop.isStopped())
                return false;
            let t = this.lexer.peek();
            const bp = this.bp(t);
            return opts.terminals.reduce((canContinue, rbpOrType) =&gt; {
                if (!canContinue)
                    return false;
                if (typeof rbpOrType == &apos;number&apos;)
                    return rbpOrType &lt; bp;
                if (typeof rbpOrType == &apos;string&apos;)
                    return t.type != rbpOrType;
            }, true);
        };
        const mkinfo = (token) =&gt; {
            const bp = this.bp(token);
            return { token, bp, stop, ctx: opts.ctx };
        };
        if (!opts.terminals)
            opts.terminals = [0];
        if (opts.terminals.length == 0)
            opts.terminals.push(0);
        let left = this.nud(mkinfo(this.lexer.next()));
        while (check()) {
            const operator = this.lexer.next();
            left = this.led(Object.assign(mkinfo(operator), { left }));
        }
        return left;
    }
}
/**
 * Builds `led`/`nud` rules for a {@link Parser}
 */
export class ParserBuilder {
    /**
     * Constructs a ParserBuilder
     * See also: {@link Parser.builder}
     * @param {Parser&lt;T&gt;} parser The parser
     */
    constructor(parser) {
        this._parser = parser;
    }
    /**
     * Define `nud` for a token type
     * @param {T} tokenType The token type
     * @param {number} bp The binding power
     * @param {NudFunction&lt;T&gt;} fn The function that will parse the token
     * @return {ParserBuilder&lt;T&gt;} Returns this ParserBuilder
     */
    nud(tokenType, bp, fn) {
        this._parser._nuds.set(tokenType, fn);
        this.bp(tokenType, bp);
        return this;
    }
    /**
     * Define `led` for a token type
     * @param {T} tokenType The token type
     * @param {number} bp The binding power
     * @param {LedFunction&lt;T&gt;} fn The function that will parse the token
     * @return {ParserBuilder&lt;T&gt;} Returns this ParserBuilder
     */
    led(tokenType, bp, fn) {
        this._parser._leds.set(tokenType, fn);
        this.bp(tokenType, bp);
        return this;
    }
    /**
     * Define both `led` and `nud` for a token type at once.
     * The supplied `LedFunction` may be called with a null `left`
     * parameter when invoked from a `nud` context.
     * @param {strTng} tokenType The token type
     * @param {number} bp The binding power
     * @param {LedFunction&lt;T&gt;} fn The function that will parse the token
     * @return {ParserBuilder&lt;T&gt;} Returns this ParserBuilder
     */
    either(tokenType, bp, fn) {
        return this.nud(tokenType, bp, ({ token, bp, stop, ctx }) =&gt; fn({ left: null, token, bp, stop, ctx })).led(tokenType, bp, fn);
    }
    /**
     * Define the binding power for a token type
     * @param {T} tokenType The token type
     * @param {number} bp The binding power
     * @return {ParserBuilder&lt;T&gt;} Returns this ParserBuilder
     */
    bp(tokenType, bp) {
        this._parser._bps.set(tokenType, bp);
        return this;
    }
    /**
     * Returns the parent {@link Parser} instance
     * @returns {Parser&lt;T&gt;}
     */
    build() {
        return this._parser;
    }
}
export default Parser;
//# sourceMappingURL=index.js.map</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
